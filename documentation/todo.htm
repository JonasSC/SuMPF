<html>
	<head>
		<title>SuMPF: To do's</title>
		<link rel="stylesheet" type="text/css" href="style.css" />
		<script type="text/javascript">
			dont_go_back = true;	// This is needed for the header script at the beginning of the body tag
		</script>
	</head>
	<body>
		<script src="header.js" type="text/javascript"></script>
		<table class="maintable">
			<tr>
				<th colspan="3" class="headline">To do's</th>
			</tr>
			<tr>
				<td colspan="2" class="text">
					Here is a list of milestones and the tasks that have to be
					completed to reach the respective milestone.
				</td>
				<td class="overview">
					<ul>
						<li><nobr><a href="#nearfuture">To be done in the near future</a></nobr></li>
						<li><nobr><a href="#versionone">Until Version 1.0</a></nobr></li>
						<li><nobr><a href="#nicetohave">Nice to have stuff for future releases</a></nobr></li>
						<li><nobr><a href="#weirdideas">Weird ideas that might be working some day</a></nobr></li>
					</ul>
				</td>
			</tr>
			<tr>
				<td colspan="3" class="section">
					<a name="nearfuture">To be done in the near future</a>
					<a href="#top" class="toplink">Top&uarr;</a>
				</td>
			</tr>
			<tr>
				<td class="subsection">Lazy execution</td>
				<td colspan="2" class="text">
					Currently, the connectors update the data in the processing
					chain as soon as they are called. This can result in unnessesary
					computations and a sluggish user experience, as the point in
					time, when the time consuming calculations shall be performed,
					cannot be chosen intuitively and comfortably.<br />
					The connectors' behaviour shall be modified in a way, that
					the computations are only done, when retrieving a result of
					the processing chain.<br />
					Of course certain input connectors like those of the plots
					must not be lazy, so they still update the plots as soon as
					new data is available. Furthermore, the lazyness must be
					transparent in a way, that the order, in which the methods are
					called is kept and that disconnecting a signal processing
					chain shall leave all objects in an updated state.
				</td>
			</tr>
			<tr>
				<td class="subsection">Processing chains inside classes</td>
				<td colspan="2" class="text">
					SuMPF's connectors offer no API to include a processing chain
					inside an object into a processing chain of which that object
					is a part. This way many of the convenient features of the
					connectors become ineffective for the encapsulated processing
					chain.<br />
					The required feature would be very convenient for "macros",
					that combine several signal processing steps, that are often
					used together, in one class (e.g. for computing a transfer function).
				</td>
			</tr>
			<tr>
				<td class="subsection">OS dependent default config paths</td>
				<td colspan="2" class="text">
					The default paths for the configuration files are currently
					very Unix-like. They work on Debian GNU/Linux, they will most
					likely work on MacOS, but they will certainly fail on Microsoft
					Windows.<br />
					There has to be an operating system check in the configuration
					defaults that sets the paths accordingly.
				</td>
			</tr>
			<tr>
				<td class="subsection">Switch to a different GUI library</td>
				<td colspan="2" class="text">
					As wxPython is only available for Python2, it is necessary
					to switch to an alternative.<br />
					Maybe this also solves the threading issues on Windows, that
					occur with the current implementation.<br />
					PyQt5 seems to become the most widely used GUI library for
					Python. Due to this reason and because of its great set of
					features, it would be nice to switch to PyQt5, but at the
					moment, I have not managed to get PyQt5 running in a different
					thread than the main thread. This is a key requirement for
					SuMPF's GUI library, because it shall be possible to display
					plots, while doing other tasks in the main thread (e.g.
					interactive signal processing in the terminal).
				</td>
			</tr>
			<tr>
				<td class="subsection">Threading issues in the GUI</td>
				<td colspan="2" class="text">
					The GUI components do not work on Windows. When showing a
					plot window, it just hangs forever.<br />
					This is probably due to the fact, that in SuMPF, the event loop
					of the GUI is not run in the main thread, but it is swapped
					to a different thread to allow a concurrent display of plots,
					while doing signal processing in the main thread.
				</td>
			</tr>
			<tr>
				<td class="subsection">Mute error output when JACK is not running</td>
				<td colspan="2" class="text">
					When a sound card interface is created with
					<span class="code">sumpf.modules.audioio.factory()</span>
					and PyJack is available, the factory method tries to initialize
					a sound card interface that uses JACK. If the JACK server is
					not running, this initialization fails, the factory method
					creates another interface and all is well. But PyJack never
					the less outputs an error message, which is unfortunate because
					everything is in a legal state.<br />
					So far I have not found a solution to mute this error message.
					It might be necessary, to patch PyJack by either removing the
					error message or (which would be better) by providing a
					"Check-if-JACK-is-running"-method.
				</td>
			</tr>
			<tr>
				<td colspan="3" class="section">
					<a name="versionone">Until Version 1.0</a>
					<a href="#top" class="toplink">Top&uarr;</a>
				</td>
			</tr>
			<tr>
				<td class="subsection">Make cursors in plots interactive</td>
				<td colspan="2" class="text">
					The cursors in the plots should be dragable with the mouse.
					This way it should be possible to interactively enter a
					value or an interval from the x-Axis.<br />
					This can be useful for example to specify the fade out interval
					of a window function.
				</td>
			</tr>
			<tr>
				<td class="subsection">Reverberation time</td>
				<td colspan="2" class="text">
					It should be possible to record and calculate the reverberation
					time. A module that recognizes a steady fall of the RMS sound
					pressure and then calculates the reverberation time from that
					is needed.
				</td>
			</tr>
			<tr>
				<td class="subsection">FFT vs. Time</td>
				<td colspan="2" class="text">
					It should be possible to create and plot a series of short time
					spectrums over time.<br />
					For that a data container and a plot is needed as well.<br />
					The container and the plot should also support a non-equidistant
					frequency sampling, like it can occur with wavelet transforms<br />
					Maybe it is possible to create a very general containter that
					could also store data like "spectrum vs. rotation" (or some
					other parameter of the device that created the generated noise).
				</td>
			</tr>
			<tr>
				<td colspan="3" class="section">
					<a name="nicetohave">Nice to have stuff for future releases</a>
					<a href="#top" class="toplink">Top&uarr;</a>
				</td>
			</tr>
			<tr>
				<td class="subsection">Debian Package</td>
				<td colspan="2" class="text">
					It would be nice to have an easy to install package for Debian.
				</td>
			</tr>
			<tr>
				<td class="subsection">JACK latency API</td>
				<td colspan="2" class="text">
					The sound card interface that uses JACK currently uses a very
					crude (and often false) method to compensate the latency from
					the sound card buffers in a recorded Signal.<br />
					It is necessary to extend PyJack with the functionalities of
					the JACK latency API and then make use of that in the respective
					sound card interface.
				</td>
			</tr>
			<tr>
				<td class="subsection">Automated downsampling</td>
				<td colspan="2" class="text">
					Currently it is not possible, to plot very large data sets,
					like audio signals that are longer than five seconds. This
					is because the pixel resolution of the plots is much lower
					than what is necessary to visualize such a vast amount of
					data.<br />
					To comfortably plot data sets of any size, a system is required
					that automatically detects, if downsampling the data is necessary,
					and reduces the data, if it is.<br />
					The basic framework for using downsamplers with the plot data
					is implemented, but useful implementations of downsampling
					algorithms are still missing.
				</td>
			</tr>
			<tr>
				<td class="subsection">Quantisation</td>
				<td colspan="2" class="text">
					It would be nice to be able to reduce the resolution of a
					Signal to a given number of steps. It should also be possible
					to specify a function for the quantisation like "linear",
					"a-Law" or "u-Law"
				</td>
			</tr>
			<tr>
				<td class="subsection">Parallel Calculations</td>
				<td colspan="2" class="text">
					It should be possible to parallelize the calculations, so they
					run faster on multicore computers.<br />
					This could be implemented in the (Output-)Connector classes.<br />
					Currently there is the problem, that sharing large data sets
					like Signals or Spectrums via shared memory or queues is so
					slow, that this outweights the performance gains, that can be
					achieved by parallel calculations.<br />
					It is possible to allocate arrays in shared memory and cast
					them to NumPy arrays. The casting is necessary to support
					complex numbers, which the shared memory arrays don't do.
					This of course makes SuMPF dependent on NumPy, which is undesired
					at the moment, because its basic functions (mainly the connectors)
					shall be available without having to install additional libraries
					other than the standard library, that comes with Python.
				</td>
			</tr>
			<tr>
				<td class="subsection">Jack Transport</td>
				<td colspan="2" class="text">
					Wouldn't it be cool if sumpf could react on Jack Transport events?
				</td>
			</tr>
			<tr>
				<td class="subsection">An interface to an electronic circuit simulator</td>
				<td colspan="2" class="text">
					It should be possible to write a Signal to a file which could
					be taken as an input value table for an electronic circuit
					simulation. The output of the simulation could also be written
					to a file which can then be plotted or even auralized in SuMPF.
					Maybe pipes or stdin/stdout can be used instead of files.
				</td>
			</tr>
			<tr>
				<td class="subsection">Filter-Input for sweeps</td>
				<td colspan="2" class="text">
					It would be useful to be able to connect a filter to a sweep.
					The sweep will then sweep slower through frequencies that have
					a high value in the filter, while it sweeps faster through
					frequencies that have a small value in the filter.
					The start- and stop-frequencies and the sweep length should
					not be altered.<br />
					This has to be done by creating the sweep in the frequency
					domain.
				</td>
			</tr>
			<tr>
				<td class="subsection">GUI</td>
				<td colspan="2" class="text">
					A Graphical user interface is needed that gives the user
					a patchbay to plug the modules into each other.
					As a start a simple GUI similar to QjackCtl could be implemented.
					But a full blown GUI like the one of Alsa Modular Synth would
					be better.<br />
					Maybe libraries like <a href="http://drobilla.net/software/ganv">Ganv</a>
					or <a href="http://www.graphviz.org/">GraphViz</a> can be helpful
					here. Also switching to a Qt based GUI library might provide
					the necessary features (both QjackCtl and Alsa Modular Synth
					use Qt).
				</td>
			</tr>
			<tr>
				<td class="subsection">Psychoacoustics</td>
				<td colspan="2" class="text">
					It would be nice to be able to calculate the parameters
					"loudness", "sharpness" and "harshness" for a given Signal.
				</td>
			</tr>
			<tr>
				<td class="subsection">Find resonance peaks</td>
				<td colspan="2" class="text">
					It would be nice to be able to find resonace peaks in a given
					spectrum and get their Q-factor.
				</td>
			</tr>
			<tr>
				<td colspan="3" class="section">
					<a name="weirdideas">Weird ideas that might be working some day</a>
					<a href="#top" class="toplink">Top&uarr;</a>
				</td>
			</tr>
			<tr>
				<td class="subsection">Symbolic signal processing</td>
				<td colspan="2" class="text">
					At the moment, SuMPF's signals and spectrums are represented
					numerically as a sequence of samples. For some tasks it would
					be beneficial to represent those data sets as a formula and
					a set of parameters. This would allow:
					<ul>
						<li>Transform IIR filters to the z-domain in order to apply them in the time domain</li>
						<li>Being independent of the sampling rate or the frequency resolution</li>
						<li>Computing an inverse without having to consider numerical problems, such as the periodicity of the fft</li>
						<li>Doing certain operations fully losslessly, without adding noise due to the limited floating point precision</li>
					<ul>
				</td>
			</tr>
			<tr>
				<td class="subsection">Loudspeaker calculations</td>
				<td colspan="2" class="text">
					Maybe some of the following tasks might be possible with SuMPF
					one day:
					<ul>
						<li>Do a recording and calculate a loudspeaker's Thiele-Small-Parameters from it</li>
						<li>Calculate optimal crossover frequencies for multi-way loudspeakers</li>
						<li>Calculate the dimensions of an optimal bass reflex port</li>
					<ul>
				</td>
			</tr>
			<tr>
				<td class="subsection">A feedback loop</td>
				<td colspan="2" class="text">
					A module that implements a feedback loop for processing chains.
					This could be similar to Simulink.
				</td>
			</tr>
			<tr>
				<td></td>
				<td width="100%"></td>
				<td></td>
			</tr>
		</table>
	</body>
</html>

