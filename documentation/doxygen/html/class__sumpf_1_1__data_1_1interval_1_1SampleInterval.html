<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SuMPF: _sumpf._data.interval.SampleInterval Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SuMPF
   &#160;<span id="projectnumber">0.01</span>
   </div>
   <div id="projectbrief">Sound&nbsp;using&nbsp;a&nbsp;Monkeyforest-like&nbsp;Processing&nbsp;Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>_sumpf</b></li><li class="navelem"><b>_data</b></li><li class="navelem"><b>interval</b></li><li class="navelem"><a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html">SampleInterval</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">_sumpf._data.interval.SampleInterval Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for unifying the definition of sample intervals throughout SuMPF.  
 <a href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for _sumpf._data.interval.SampleInterval:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class__sumpf_1_1__data_1_1interval_1_1SampleInterval__coll__graph.png" border="0" usemap="#__sumpf_8__data_8interval_8SampleInterval_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab91222a9acea30c8535da2016f213b40"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html#ab91222a9acea30c8535da2016f213b40">__init__</a> (self, start=0, stop=None)</td></tr>
<tr class="memdesc:ab91222a9acea30c8535da2016f213b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters are the boundaries of the interval.  <a href="#ab91222a9acea30c8535da2016f213b40">More...</a><br /></td></tr>
<tr class="separator:ab91222a9acea30c8535da2016f213b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9912952ceabdba9ce94cdf1f1f6a2ed3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html#a9912952ceabdba9ce94cdf1f1f6a2ed3">__eq__</a> (self, other)</td></tr>
<tr class="memdesc:a9912952ceabdba9ce94cdf1f1f6a2ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called when two SampleIntervals are compared with ==.  <a href="#a9912952ceabdba9ce94cdf1f1f6a2ed3">More...</a><br /></td></tr>
<tr class="separator:a9912952ceabdba9ce94cdf1f1f6a2ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fb324ebffa9556be4f32ed634e57da"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html#ac3fb324ebffa9556be4f32ed634e57da">__ne__</a> (self, other)</td></tr>
<tr class="memdesc:ac3fb324ebffa9556be4f32ed634e57da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called when two SampleIntervals are compared with !=.  <a href="#ac3fb324ebffa9556be4f32ed634e57da">More...</a><br /></td></tr>
<tr class="separator:ac3fb324ebffa9556be4f32ed634e57da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ac715ff349db040a411672aba112d7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html#a50ac715ff349db040a411672aba112d7">GetIndices</a> (self, length)</td></tr>
<tr class="memdesc:a50ac715ff349db040a411672aba112d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the start and stop index of the interval as a tuple of integers.  <a href="#a50ac715ff349db040a411672aba112d7">More...</a><br /></td></tr>
<tr class="separator:a50ac715ff349db040a411672aba112d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0097580057a5e517df3cdb8e15887077"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html#a0097580057a5e517df3cdb8e15887077">GetSlice</a> (self, length)</td></tr>
<tr class="memdesc:a0097580057a5e517df3cdb8e15887077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice object, that can be passed to the <b>getitem</b> method of the data set: d = [0, 1, 2, 3, 4, 5] s = sumpf.SampleInterval(2, 4) d[s.GetSlice(len(d))] # [2, 3, 4].  <a href="#a0097580057a5e517df3cdb8e15887077">More...</a><br /></td></tr>
<tr class="separator:a0097580057a5e517df3cdb8e15887077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972f7d958cf6f42381cce499212d82e4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html#a972f7d958cf6f42381cce499212d82e4">IsExcessive</a> (self, length)</td></tr>
<tr class="memdesc:a972f7d958cf6f42381cce499212d82e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True, if the interval exceeds the limits of the data set by either producing a negative start index or by producing a stop index, that is greater than the length of the data set.  <a href="#a972f7d958cf6f42381cce499212d82e4">More...</a><br /></td></tr>
<tr class="separator:a972f7d958cf6f42381cce499212d82e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c97df4aeac324f038cc384ece76ad9e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html#a6c97df4aeac324f038cc384ece76ad9e">IsReversed</a> (self, length)</td></tr>
<tr class="memdesc:a6c97df4aeac324f038cc384ece76ad9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True, if the stop index of the interval is smaller than the start index.  <a href="#a6c97df4aeac324f038cc384ece76ad9e">More...</a><br /></td></tr>
<tr class="separator:a6c97df4aeac324f038cc384ece76ad9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2c5f2cc25646152d8a567011821fb790"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html#a2c5f2cc25646152d8a567011821fb790">factory</a> (start=0, stop=None)</td></tr>
<tr class="memdesc:a2c5f2cc25646152d8a567011821fb790"><td class="mdescLeft">&#160;</td><td class="mdescRight">a static factory method, that creates a new <a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html" title="A class for unifying the definition of sample intervals throughout SuMPF. ">SampleInterval</a> method from the given parameters, if the parameters are not a <a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html" title="A class for unifying the definition of sample intervals throughout SuMPF. ">SampleInterval</a> instance already.  <a href="#a2c5f2cc25646152d8a567011821fb790">More...</a><br /></td></tr>
<tr class="separator:a2c5f2cc25646152d8a567011821fb790"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for unifying the definition of sample intervals throughout SuMPF. </p>
<p>It is not necessary to specify intervals as <a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html" title="A class for unifying the definition of sample intervals throughout SuMPF. ">SampleInterval</a> instances, when using SuMPF's signal processing classes. They can be given as tuples or single values and will be cast to a <a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html" title="A class for unifying the definition of sample intervals throughout SuMPF. ">SampleInterval</a> internally. Examples for this are given at the end of this docstring.</p>
<p>The start index of the interval defines the index of the first sample, which is inside the interval, while the stop index points at the first sample after the interval. This behavior is equal to the indexing, that is used for slicing. Indices, that exceed the scope of the data set by producing a negative start index or a stop index, which is greater than the data set's length, are not forbidden, but depending on the application of the interval, they might cause errors.</p>
<p>An interval's boundaries can be specified as integers or floats. Integers are interpreted as static sample indices, which are independent of the data set's length. Floats define the interval's boundaries relative to the data set's length, where 0.0 indexes the first sample and 1.0 the sample at the index of the length of the data set, which is the index, that would come after the last sample's index (compare: a=[1,2,3]; a[len(a)]). Similar to Python's indexing, positive interval boundaries are interpreted as being relative to the beginning of the data set, while negative ones are considered as offsets from the end of the data set. An interval definition can be abbreviated by giving only a single number. When an interval is created from a positive number, the interval will span from the start of the data set to the index, that is defined by this number. With a negative number, the interval will span from this negative index until the end of the data set.</p>
<p>Examples: </p><h1>it is not necessary to pass <a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html" title="A class for unifying the definition of sample intervals throughout SuMPF. ">SampleInterval</a> instances. Tuples or even numbers will do</h1>
<p>sumpf.modules.WindowGenerator(fall_interval=(768, 1024)) </p><h1>defining static boundaries</h1>
<p>tuple(range(10))[sumpf.SampleInterval(2, 6).GetSlice(10)] # (2, 3, 4, 5) tuple(range(10))[sumpf.SampleInterval(-6, -2).GetSlice(10)] # (4, 5, 6, 7) </p><h1>defining relative boundaries</h1>
<p>tuple(range(10))[sumpf.SampleInterval(0.2, 0.6).GetSlice(10)] # (2, 3, 4, 5) tuple(range(10))[sumpf.SampleInterval(-0.6, -0.2).GetSlice(10)] # (4, 5, 6, 7) </p><h1>abbreviations</h1>
<p>tuple(range(10))[sumpf.SampleInterval(3).GetSlice(10)] # (0, 1, 2) tuple(range(10))[sumpf.SampleInterval(-0.3).GetSlice(10)] # (7, 8, 9) </p><h1>integers and floats can be mixed</h1>
<p>tuple(range(10))[sumpf.SampleInterval(7, 1.0).GetSlice(10)] # (7, 8, 9) from index 7 till the end </p><h1>the boundaries can also be passed as an Iterable</h1>
<p>tuple(range(10))[sumpf.SampleInterval((2, 6)).GetSlice(10)] # (2, 3, 4, 5) </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab91222a9acea30c8535da2016f213b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91222a9acea30c8535da2016f213b40">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def _sumpf._data.interval.SampleInterval.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stop</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameters are the boundaries of the interval. </p>
<p>If the definition of the interval is abbreviated to just one number or the boundaries are defined by an integer, both boundaries are derrived from the start parameter, while the stop parameter is left being None. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>an integer, a float, an Iterable </td></tr>
    <tr><td class="paramname">stop</td><td>optional, an integer or a float </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9912952ceabdba9ce94cdf1f1f6a2ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9912952ceabdba9ce94cdf1f1f6a2ed3">&#9670;&nbsp;</a></span>__eq__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def _sumpf._data.interval.SampleInterval.__eq__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is called when two SampleIntervals are compared with ==. </p>
<p>It returns True, when both intervals are equal and False otherwise. Due to the limited precision of floating point numbers, testing for equality might fail, even when the intervals are equal in practice: <a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html" title="A class for unifying the definition of sample intervals throughout SuMPF. ">SampleInterval</a>(0.0, 1.0) == <a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html" title="A class for unifying the definition of sample intervals throughout SuMPF. ">SampleInterval</a>(-1.0, 1.0) # works everytime <a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html" title="A class for unifying the definition of sample intervals throughout SuMPF. ">SampleInterval</a>(0.3, 0.68) == <a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html" title="A class for unifying the definition of sample intervals throughout SuMPF. ">SampleInterval</a>(-0.7, -0.32) # might return False, although the intervals are equal </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the <a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html" title="A class for unifying the definition of sample intervals throughout SuMPF. ">SampleInterval</a> to which this interval shall be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"></td><td>True, if the intervals are equal, False otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3fb324ebffa9556be4f32ed634e57da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fb324ebffa9556be4f32ed634e57da">&#9670;&nbsp;</a></span>__ne__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def _sumpf._data.interval.SampleInterval.__ne__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is called when two SampleIntervals are compared with !=. </p>
<p>It returns False, when both intervals are equal and True otherwise. See the <b>eq</b> method for information on floating point issues. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the <a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html" title="A class for unifying the definition of sample intervals throughout SuMPF. ">SampleInterval</a> to which this interval shall be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"></td><td>True, if the intervals are not equal, False otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c5f2cc25646152d8a567011821fb790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5f2cc25646152d8a567011821fb790">&#9670;&nbsp;</a></span>factory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def _sumpf._data.interval.SampleInterval.factory </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stop</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a static factory method, that creates a new <a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html" title="A class for unifying the definition of sample intervals throughout SuMPF. ">SampleInterval</a> method from the given parameters, if the parameters are not a <a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html" title="A class for unifying the definition of sample intervals throughout SuMPF. ">SampleInterval</a> instance already. </p>
<p>Parameters are the boundaries of the interval. If the definition of the interval is abbreviated to just one number or the boundaries are defined by an integer, both boundaries are derrived from the start parameter, while the stop parameter is left being None. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>an integer, a float, an Iterable or a <a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html" title="A class for unifying the definition of sample intervals throughout SuMPF. ">SampleInterval</a> instance </td></tr>
    <tr><td class="paramname">stop</td><td>optional, an integer or a float </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"></td><td>a <a class="el" href="class__sumpf_1_1__data_1_1interval_1_1SampleInterval.html" title="A class for unifying the definition of sample intervals throughout SuMPF. ">SampleInterval</a> instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50ac715ff349db040a411672aba112d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ac715ff349db040a411672aba112d7">&#9670;&nbsp;</a></span>GetIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def _sumpf._data.interval.SampleInterval.GetIndices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the start and stop index of the interval as a tuple of integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the length of the data set to which the interval shall be applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"></td><td>a tuple of two integers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0097580057a5e517df3cdb8e15887077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0097580057a5e517df3cdb8e15887077">&#9670;&nbsp;</a></span>GetSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def _sumpf._data.interval.SampleInterval.GetSlice </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a slice object, that can be passed to the <b>getitem</b> method of the data set: d = [0, 1, 2, 3, 4, 5] s = sumpf.SampleInterval(2, 4) d[s.GetSlice(len(d))] # [2, 3, 4]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the length of the data set to which the interval shall be applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"></td><td>a tuple of two integers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a972f7d958cf6f42381cce499212d82e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972f7d958cf6f42381cce499212d82e4">&#9670;&nbsp;</a></span>IsExcessive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def _sumpf._data.interval.SampleInterval.IsExcessive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns True, if the interval exceeds the limits of the data set by either producing a negative start index or by producing a stop index, that is greater than the length of the data set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the length of the data set to which the interval shall be applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"></td><td>True if the interval exceeds the limits of the data set, False otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c97df4aeac324f038cc384ece76ad9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c97df4aeac324f038cc384ece76ad9e">&#9670;&nbsp;</a></span>IsReversed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def _sumpf._data.interval.SampleInterval.IsReversed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns True, if the stop index of the interval is smaller than the start index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the length of the data set to which the interval shall be applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"></td><td>True if the interval boundaries are reversed, False otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>source/_sumpf/_data/interval.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Nov 11 2018 13:23:01 for SuMPF by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
