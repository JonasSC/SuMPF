<html>
	<head>
		<title>SuMPF: Connectors</title>
		<link rel="stylesheet" type="text/css" href="style.css" />
		<script type="text/javascript">
			dont_go_back = true;	// This is needed for the header script at the beginning of the body tag
		</script>
	</head>
	<body>
		<script src="header.js" type="text/javascript"></script>
		<table class='maintable'>
			<tr>
				<th colspan="3" class="headline">Connectors</th>
			</tr>
			<tr>
				<td colspan="2" class="text">
					The connectors system in SuMPF is a set of decorators and
					functions that can be used to connect objects, so that
					a changed value in one object triggers an update of the
					other objects as well.<br />
					The decorators are used to replace setter and getter methods
					with connector objects. These objects can then be connected
					or disconnected with the provided functions.<br />
					If the decorated methods are not called through the connectors
					system, their behaviour will not have changed. They are still
					usable as the setter and getter methods, just like they were
					implemented.<br />
					If a setter of an object is called, it will notify the getters
					of that object, whose return value might have changed. These
					getters will than in turn notify the connected setters, so
					they retrieve the updated value.
				</td>
				<td class="overview">
					<ul>
						<li><nobr><a href="#DecoAndFunc">Decorators and Functions</a></nobr></li>
						<li><nobr><a href="#Differences">Differences to ordinary methods</a></nobr></li>
						<li><nobr><a href="#Example">An Example</a></nobr></li>
						<li><nobr><a href="#Features">Features</a></nobr></li>
					</ul>
				</td>
			</tr>
			<tr>
				<th colspan="3" class="section">
					<a name="Differences">Differences to ordinary methods</a>
					<a href="#top" class="toplink">Top&uarr;</a>
				</th>
			</tr>
			<tr>
				<td colspan="3" class="text">
					The decorated methods are replaced by connector objects that
					mimic the functionality of the method as closely as possible.
					So a connector method can still be called like an ordinary
					method. But never the less, there are some differences between
					a method and its according connector object.
				</td>
			</tr>
			<tr>
				<td class="subsection">Typechecks</td>
				<td colspan="2" class="text">
					As the methods are replaced with connector objects, typechecks
					that query the type of the decorated method have to be done
					differently.<br />
					Calling <span class="code">type(...)</span> with a decorated
					method as a parameter will not return the
					<span class="code">instancemethod</span> type, but the type
					of the according connector object.
				</td>
			</tr>
			<tr>
				<td class="subsection">Help and Docstrings</td>
				<td colspan="2" class="text">
					Since the decorated methods are replaced by connector objects,
					calling the python builtin help function will output the help
					for the connector object.<br />
					During the initialization of the connector the docstring of
					the method (<span class="code">__doc__</span>) will be copied
					into the docstring of the connector instance. This way a
					description of an object's method can be retrieved by
					<span class="code">object.method.__doc__</span>.
				</td>
			</tr>
			<tr>
				<td class="subsection">Garbage Collection</td>
				<td colspan="2" class="text">
					The decorated methods are replaced by an object that holds a
					(weak) reference to the instance, of which the method is a
					member, while the instance has of course a reference to the
					method (see also <a href="#connectors_in_constructor">below</a>).
					<br />
					Normally, these circular references can be garbage collected
					as usual. But if the instance has a destructor method
					(<span class="code">__del__</span>), the garbage collector
					cannot decide whether it shall destroy the connector object
					or the instance first.<br />
					In this case it is recommended to use SuMPF's
					<span class="code">collect_garbage</span> function to invoke
					the garbage collection. This function recognizes the deletable
					connector objects and deletes their reference to the instance.
					This way the garbage collection is no longer confused by the
					connectors.<br />
					Alternatively you can call the
					<span class="code">destroy_connectors</span> function with the
					object, you want to delete, as parameter. After that a normal
					call of gc.collect will work as well.
				</td>
			</tr>
			<tr>
				<td class="subsection"><a name="connectors_in_constructor">Calling connectors in the constructor</a></td>
				<td colspan="2" class="text">
					Calling methods, that are decorated as connectors in the
					constructor is forbidden. <br />
					This is due to the fact, that the actual connector only holds
					a weak reference to its instance, to avoid circular references
					and reduce the number of times, when the garbage collector
					has to be invoked. But in case, a method is called directly
					after instantiating a class, without storing this instance
					somewhere (e.g. <nobr><span class="code">value = Class().Connector()</span></nobr>),
					the reference counter of the instance would be zero before
					entering the connector method, so that it was deleted and the
					weak reference of the connector method to the instance would
					be invalid, during the run of the method. To avoid this, the
					first time, the connector is accessed, a proxy connector is
					created, that holds a hard reference to the instance. If the
					connector is now accessed within the constructor, this proxy
					object would be wasted in there, so that direct method calls
					without storing a reference to the instance would become impossible
					again.<br />
					A unit test has been written, that checks, if a Connector
					method is called from the constructor. This unit test does
					not test, if the constructor calls a regular method, which
					then calls a Connector. Obviously, this can also lead to
					premature deletion of the instance.
				</td>
			</tr>
			<tr>
				<th colspan="3" class="section">
					<a name="DecoAndFunc">Decorators and Functions</a>
					<a href="#top" class="toplink">Top&uarr;</a>
				</th>
			</tr>
			<tr>
				<td colspan="3" class="text">Decorators</td>
			</tr>
			<tr>
				<td class="subsection">Input</td>
				<td colspan="2" class="text">
					This is the usual decorator for setter methods. A decorated
					setter method should take exactly one parameter.<br />
					When another connector is connected to an Input, the Input
					will retrieve the value of the other connector directly after
					creating the connection.<br />
					Breaking the connection will not cause the setter to be
					called again. The set attribute will not be reset to a neutral
					value or the value, which it had before creating the
					connection.<br />
					The Input decorator takes two parameters:
					<ol>
						<li>
							<b>data_type:</b> This specifies the type of the
							connector. Only output connectors that return a
							compatible value can be connected to this connector.
							The given data type can be either one type or a tuple
							of valid types.
						</li>
						<li>
							<b>observers:</b> This is a list of string names of
							the getter methods that are affected when this setter
							is called. The class must have all methods whose name
							is given here and all of them have to be decorated
							with "Output".
						</li>
					</ol>
				</td>
			</tr>
			<tr>
				<td class="subsection">MultiInput</td>
				<td colspan="2" class="text">
					This is the decorator which is suitable for methods that add
					a data set to a container. A data set will be added when a
					connection is created to a MultiInput. The data set will be
					removed when the connection is broken.<br />
					To provide this functionality, a remove method has to be
					specified, which is called when the connection is broken.
					This remove method does not need to be decorated, never the
					less it will also be replaced by an object, just like the
					decorated methods.<br />
					Optionally, a replace method can be specified. This method is
					called, when a connected output changes his value.<br />
					A method which is decorated with MultiInput must take exactly
					one parameter. It must return an id with which the remove
					method can be called to remove the data given as parameter.<br />
					The MultiInput decorator takes three parameters:
					<ol>
						<li>
							<b>data_type:</b> This specifies the type of the
							connector. Only output connectors that return a
							compatible value can be connected to this connector.
						</li>
						<li>
							<b>remove_method:</b> This is the string name of the
							remove method.
						</li>
						<li>
							<b>observers:</b> This is a list of string names of
							the getter methods that are affected when this setter
							is called. The class must have all methods whose name
							is given here and all of them have to be decorated
							with "Output".
						</li>
						<li>
							<b>replace_method:</b> The optional name of a method
							that will be used, to replace data, when the value of
							a connected output has changed.
						</li>
					</ol>
				</td>
			</tr>
			<tr>
				<td class="subsection">Output</td>
				<td colspan="2" class="text">
					This is the decorator for getter methods.<br />
					The decorated method must be callable without any parameters.<br />
					A getter can be connected to multiple setters.<br />
					The Output decorator takes one mandatory parameter and one
					optional parameter:
					<ol>
						<li>
							<b>data_type:</b> This specifies the type of the
							connector. Only input connectors that expect a value
							with this type can be connected to this connector.
						</li>
						<li>
							<b>caching:</b> This parameter enables or disables
							caching.<br />
							If caching is disabled, the getter method
							will be called every time when a value is retrieved
							from the Output.<br />
							If caching is enabled, the return value of the getter
							method will be stored and only the stored value will
							be returned. The restored value will also be returned
							when the Output is called as normal method and not
							through connections.<br />
							The stored value will be updated when the Output is
							called after an Input that is observed by this Output
							has changed the state of the object.<br />
							The caching parameter can have three values:
							<ul>
								<li><i>False:</i> to disable caching</li>
								<li><i>None:</i> to look in the config if caching shall be enabled. This is the default value.</li>
								<li><i>True:</i> to enable caching</li>
							</ul>
							Please note that caching might lead to wrong return
							values if not all setter methods are set up to notify
							the Output properly. It is also problematic if the
							getter method changes the state of its object.
						</li>
					</ol>
				</td>
			</tr>
			<tr>
				<td class="subsection">Trigger</td>
				<td colspan="2" class="text">
					This is a decorator for methods that just trigger something
					inside their instances. Usually methods like "start" can be
					decorated as a Trigger.<br />
					To be decorated, they have to be callable without any arguments.<br />
					Other than the other input connectors Input and MultiInput,
					a Trigger is not triggered by creating a connection to it.<br />
					A Trigger has no data_type, so any Output connector can be
					connected to it. If the connected Output connector has a new
					value, the Trigger will be triggered.<br />
					A Trigger decorator takes only one parameter:
					<ol>
						<li>
							<b>observers:</b> This is a list of string names of
							the getter methods that are affected when this setter
							is called. The class must have all methods whose name
							is given here and all of them have to be decorated
							with "Output".
						</li>
					</ol>
				</td>
			</tr>
			<tr>
				<td colspan="3" class="text">Functions</td>
			</tr>
			<tr>
				<td class="subsection">activate_output</td>
				<td colspan="2" class="text">
					Reactivates Output connectors that have been disabled with
					deactivate_output.<br />
					Activated Output connectors notify connected input decorators
					when the Output's value has changed.<br />
					When an Output connector is reactivated, it checks if there
					were changes during its inactive time that make an update
					necessary. If it is so, it notifies the connected input
					connectors.<br />
					activate_output takes one parameter:
					<ol>
						<li>
							<b>obj:</b> This is the instance whose automatic
							notification shall be activated. The instance can
							either be an Output connector, in which case that
							connector will be activated. Or it can be an object,
							in which case all Output connectors of that object
							will be activated.
						</li>
					</ol>
				</td>
			</tr>
			<tr>
				<td class="subsection">connect</td>
				<td colspan="2" class="text">
					Connects an Output connector to an Input, MultiInput or Trigger
					connector. Changes in the Output connector's value will then
					be passed automaticly to the connected inputs.<br />
					When an output is connected to an Input or MultiInput connector,
					the input connectors will be notified directly after connecting.
					When the output is connected to a Trigger, the Trigger will
					not be triggered by making the connection.<br />
					connect takes two parameters:
					<ol>
						<li>
							<b>a, b:</b> These are the connectors that shall be
							connected. One of them must be an Output connector,
							the other has to be an Input, MultiInput or Trigger
							connector. The order which connector is given first
							is not important.
						</li>
					</ol>
				</td>
			</tr>
			<tr>
				<td class="subsection">deactivate_output</td>
				<td colspan="2" class="text">
					Deactivates Output connectors. Deactivated Output connectors
					do not notify connected input decorators when the Output's
					value has changed.<br />
					deactivate_output takes one parameter:
					<ol>
						<li>
							<b>obj:</b> This is the instance whose automatic
							notification shall be deactivated. The instance can
							either be an Output connector, in which case that
							connector will be deactivated. Or it can be an object,
							in which case all Output connectors of that object
							will be deactivated.
						</li>
					</ol>
				</td>
			</tr>
			<tr>
				<td class="subsection">destroy_connectors</td>
				<td colspan="2" class="text">
					Destroys all connectors of an object, so it can be garbage
					collected.<br />
					This is only necessary when the object has a destructor (a
					__del__ method). Objects without destructor can be garbage
					collected as usual.<br />
					This method is only useful, when the garbage collection is
					started with gc.collect(). It is recommended to start the
					garbage collection with sumpf.collect_garbage(). This will
					call the destroy_connectors function, so it needs not be
					called manually for each object.
				</td>
			</tr>
			<tr>
				<td class="subsection">disconnect</td>
				<td colspan="2" class="text">
					Breaks a connection that has been made with sumpf.connect(.).<br />
					If a MultiInput connector is being disconnected, the value
					of the disconnected output will be removed with the MultiInput's
					remove method. So the MultiInput will be notified when a
					connection to it is being disconnected. Input and Trigger
					connectors will not be notified during breaking a connection
					to them.<br />
					disconnect takes two parameters:
					<ol>
						<li>
							<b>a, b:</b> These are the connectors that shall be
							disconnected. They must have been connected before.
							The order which connector is given first, the output
							or the input, is not important.
						</li>
					</ol>
				</td>
			</tr>
			<tr>
				<td class="subsection">disconnect_all</td>
				<td colspan="2" class="text">
					Disconnects everything from the given object. The object can
					be either a connector instance like Output, Input, MultiInput
					or Trigger or of any other type that has connectors as
					attributes.<br />
					disconnect_all takes one parameter:
					<ol>
						<li>
							<b>obj:</b> The object from which everything shall
							be disconnected. The given object can either be a
							connector instance or it can be an object which has
							connectors as attributes.
						</li>
					</ol>
				</td>
			</tr>
			<tr>
				<th colspan="3" class="section">
					<a name="Example">An Example</a>
					<a href="#top" class="toplink">Top&uarr;</a>
				</th>
			</tr>
			<tr>
				<td colspan="3" class="text">
					A very simple example will be presented here. You can copy
					it to a file and execute it.<br />
					For more complex examples please have a look at the examples
					in the source folder or at the unit tests.
					<pre class="code">
# First, we need SuMPF
import sumpf

# Then we need to define a class with some demonstration methods
class Demo(object):
	def __init__(self, name):
		self.name = name
		self.value = 0
		self.id = 0
		self.added = {}

	@sumpf.Input(int, "GetValue")
	def SetValue(self, value):
		self.value = value

	@sumpf.Trigger("GetValue")
	def Triggered(self):
		self.value += 1
		print self.name, "has been triggered"

	@sumpf.MultiInput(int, "RemoveValue", "GetValue")
	def AddValue(self, value):
		self.value += value
		self.id += 1			# Of course there are better ways to implement an id system, but this one is simple
		self.added[self.id] = value
		return self.id			# With this id, the value can be removed again

	def RemoveValue(self, data_id):
		self.value -= self.added[data_id]	# remove the value
		del self.added[data_id]			# remove the obsolete id

	@sumpf.Output(int)
	def GetValue(self):
		return self.value


# Now we can instantiate our classes:
obj1 = Demo("Object 1")
obj2 = Demo("Object 2")


# These classes can now be connected
sumpf.connect(obj1.GetValue, obj2.SetValue)
# Now we can pass a value ...
obj1.SetValue(1337)
# ... and see that the connected object been updated as well
print obj2.GetValue()


# Clean up for further demos
print	# Add an empty line for better readability of the output
obj1.SetValue(0)
sumpf.disconnect_all(obj1)


# Now let's test the Triggers
sumpf.connect(obj1.GetValue, obj2.Triggered)
# Note that nothing was printed here.
# Triggers are not called while making a connection.
obj1.Triggered()
# This should have printed:
#  Object 1 has been triggered
#  Object 2 has been triggered
# The first line is printed because we have called the Trigger directly
# The second line is printed because obj1.GetValue has been notified by the
# called trigger, which then called the connected obj2.Triggered


# Clean up for further demos
print
sumpf.disconnect_all(obj1)


# Now let's test the MultiInput
obj3 = Demo("Object 3")
obj1.SetValue(1)
obj2.SetValue(2)
# The following print is still 0 because nothing is connected to obj3
print obj3.GetValue()
sumpf.connect(obj1.GetValue, obj3.AddValue)
# The following print is 1 because obj1's value has been added
print obj3.GetValue()
sumpf.connect(obj2.GetValue, obj3.AddValue)
# The following print is 3 because obj2's value has been added as well
print obj3.GetValue()
sumpf.disconnect(obj1.GetValue, obj3.AddValue)
# The following print is 2 because only obj2 is still connected
print obj3.GetValue()
sumpf.disconnect(obj2.GetValue, obj3.AddValue)
# Now it's 0 again because nothing is connected
print obj3.GetValue()


# Clean up
print
sumpf.disconnect_all(obj3)
del obj1
del obj2
del obj3
import gc
gc.collect()
print gc.garbage
# gc.garbage is an empty list. That means that all deleted objects could have
# been properly garbage collected.
# If the class Demo had a destructor, it would have been necessary to collect
# the garbage with sumpf.collect_garbage()
					</pre>
				</td>
			</tr>
			<tr>
				<th colspan="3" class="section">
					<a name="Features">Features</a>
					<a href="#top" class="toplink">Top&uarr;</a>
				</th>
			</tr>
			<tr>
				<td class="subsection">Caching</td>
				<td colspan="2" class="text">
					To avoid unnecessary recalculations in the getter methods,
					the output connectors can cache the return value of their
					getter methdod.<br />
					The getter method will only be called again if one of the
					input connectors that are observed by the output connector
					has been called.<br />
					<br />
					The caching can be switched on and of with the
					<span class="code">caching</span>-parameter of the Output
					decorator. This parameter can be one of three values:
					<ul>
						<li><b>True</b> to enable caching</li>
						<li><b>None</b> to lookup in the config, whether caching shall be enabled</li>
						<li><b>False</b> to disable caching</li>
					</ul>
					The default behavior, when the parameter is not given, is to
					lookup in the config whether to enable caching.<br />
					<br />
					Caching has to be disabled when the getter method has more
					effects than just calculating and returning the requested value.<br />
					<br />
					This implementation of caching works well, when most of the
					calculations are done in the getter methods, while the setter
					methods are kept lightweight.<br />
					When the getter method just returns a precalculated value, it
					is recommended to disable caching. This avoids a little bit
					of overhead.
				</td>
			</tr>
			<tr>
				<td class="subsection">Disabling connectors</td>
				<td colspan="2" class="text">
					If multiple parameters of an object shall be modified through
					methods, that would trigger a recalculation of the processing
					chain on every parameter change, it can be useful to disable
					the update of the processing chain, until all parameters are
					modified.<br />
					If the parameters are changed through the processing chain,
					the outputs of an object automatically wait untill all announced
					changes have been made to the object. If the parameters are
					however modified by calling the setter methods "manually",
					the outputs of the object have to be deactivated, to wait
					until all parameter changes are done.<br />
					Deactivating an output connector can be done by passing it to
					the <span class="code">sumpf.deactivate_output</span> function.
					The <span class="code">sumpf.activate_output</span> function
					reenables it again and causes the processing chain to update
					if necessary. The two functions can also take objects as a
					parameter. They will then (de)activate all outputs that are
					methods of the given object.
				</td>
			</tr>
			<tr>
				<td class="subsection">Look ahead</td>
				<td colspan="2" class="text">
					Before data is sent through a connection, the connector that
					has been changed, sends an announcement to all connectors
					that are influenced by this data change. An output connector
					will only recalculate its value and send it through the
					connection, when all observed input connectors that have got
					an announcement have also received a new value.<br />
					This helps to avoid unnecessary calculations.<br />
					<br />
					Consider the following example: The transfer function of a
					filter shall be measured by sending a sweep through it. Both
					the sweep and the response of the filter are then 
					Fourier-transformed and divided to get the transfer function:<br />
					<br />
					<img src="images/LookAheadSimple.png" style="width:100%"/><br />
					<br />
					Assume there would be no look ahead and the sweep is modified
					somehow.<br />
					In this case the following calculations would be made:
					<ol>
						<li>The sweep will be recalculated</li>
						<li>The filter response will be recalculated</li>
						<li>The fourier transform of the filter response will be updated</li>
						<li>The updated fourier transformed filter response will be divided through the <b>old</b> fourier transform of the sweep</li>
						<li>The fourier transform of the sweep will be updated</li>
						<li>The fourier transforms will be divided</li>
					</ol>
					It is obvious that one division is being made too many. If
					there were processing objects connected to the output of the
					division, all of their calculations would also have been made
					too often.<br />
					<br />
					There is even a worse case: If the length of the sweep is
					modified, the division of the updated fourier transformed
					filter response and the old fourier transform of the sweep
					will fail, because the two spectrums have a different length.<br />
					<br />
					With the look ahead these unnecessary calculations are avoided:
					<ol>
						<li>The sweep will be recalculated and send announcements to all connected objects. These objects forward these announcements</li>
						<li>The filter response will be recalculated</li>
						<li>The fourier transform of the filter response will be updated</li>
						<li>The division will <b>not</b> be performed because the division object waits for the announced value change of the sweep-fourier transform</li>
						<li>The fourier transform of the sweep will be updated</li>
						<li>The fourier transforms will be divided</li>
					</ol>
					<br />
					When there is no connection between the changed object and
					a processig object, the announcements have to be made manually.
					For example when instead of a filter, a physical object shall
					be measured by playing and recording the sweep with the
					sound card.<br />
					In this case, the recorded signal of the sound card
					will only have changed when the recording process had been
					started. Therefore the getter for the recorded signal does
					not observe the setter for the playback signal, which is why
					the announcements are not forwarded as it might be expected.
					<br />In this case the
					<span class="code">NoticeAnnouncement()</span>-method of the
					input connector of the fourier transform has to be called manually.
				</td>
			</tr>
			<tr>
				<td class="subsection">Progress indicators</td>
				<td colspan="2" class="text">
					The progress of a calculation in a processing chain can be
					tracked by progress indicator objects. These objects can be
					used to update a gauge or some other sort of progress visualization.
					<br /><br />
					There are different types of progress indicators, which count
					the number of calculation steps in a different way. This way
					the progress indicator type can be chosen to provide a more
					optimal estimate of the progress.<br />
					There are currently thee types implemented:
					<ul>
						<li>
							The <span class="code">ProgressIndicator_All</span>
							counts all sorts of connectors, that are in the processing
							chain, as calculation steps.
						</li>
						<li>
							The <span class="code">ProgressIndicator_Outputs</span>
							counts only output connectors as calculation steps.
							This gives a better estimate of the progress, when
							all the calculations are done by the getter methods,
							while the setters just store their parameters.
						</li>
						<li>
							The <span class="code">ProgressIndicator_OutputsAndNonObservedInputs</span>
							counts output connectors and input connectors, that do
							not notify any outputs, as calculation steps. This
							should give a better estimation than the
							<span class="code">ProgressIndicator_Outputs</span>,
							because at endpoints in the processing chain (like
							plots) the calculation work has to be done in the
							setter methods.
						</li>
					</ul>
					Each progress indicator provides three ways of querying the
					progress:
					<ul>
						<li>
							The <span class="code">GetProgressAsTuple</span>
							method returns a tuple (max, current), where max is
							the total number of calculation steps and current is
							the number of calculations steps that have already
							finished.
						</li>
						<li>
							<span class="code">GetProgressAsFloat</span> returns
							a floating point number between 0.0 and 1.0, where
							0.0 means that nothing has been done yet and 1.0 means
							that the calculation has finished.
						</li>
						<li>
							<span class="code">GetProgressAsPercentage</span>
							returns an integer between 0 and 100, which is the
							percentage of how much of the calculation is done so
							far.
						</li>
					</ul>
					The following code gives an example of how to use the progress
					indicator classes and SuMPF's progress dialog:
					<pre class="code">
import time
import sumpf

# define a custom progress visualization
class PrintProgress(object):
	@sumpf.Input(int)
	def SetProgress(self, percentage):
		print str(percentage) + "% done"

# define a class to set up a connection chain
class ProgressTester(object):
	def __init__(self):
		self.waiting_time = 0.0			# do not fake work, when setting up the processing chain

	@sumpf.Input(float, "GetValue")
	def SetValue(self, value):
		self.waiting_time = value
		time.sleep(self.waiting_time)	# fake some work

	@sumpf.Output(float)
	def GetValue(self):
		time.sleep(self.waiting_time)	# fake some work
		return self.waiting_time

# set up some "processing" objects and connect them to a processing chain
tester1 = ProgressTester()
tester2 = ProgressTester()
tester3 = ProgressTester()
sumpf.connect(tester1.GetValue, tester2.SetValue)
sumpf.connect(tester2.GetValue, tester3.SetValue)

# set up the ProgressIndicator
# as the calculations of the setter and the getter methods take the same amount
# of time, a ProgressIndicator_All instance is used.
# The method that is given in the constructor is the method that starts the calculation.
indicator = sumpf.progressindicators.ProgressIndicator_All(method=tester1.SetValue)

# set up an instance of the custom progress visualization
# Note that the progress indicator has different forms in which it can deliver
# the progress information. Our visualization object shall print the percentage
# of how much work is done, so it is connected to the GetProgressAsPercentage
# method.
visualization = PrintProgress()
# connect the progress indicator to the visualization
# making this connection automatically passes the "0% done" status message to the
# visualization, which causes it to print "0% done"
sumpf.connect(indicator.GetProgressAsPercentage, visualization.SetProgress)

# set up a ProgressDialog
# SuMPF's ProgressDialog expects a tuple with the maximum number of calculation
# steps and the current number of finished steps as progress information. So it
# is connected to the progress indicator's GetProgressAsTuple method.
dialog = sumpf.gui.ProgressDialog(parent=None, message="Test")
# connect the progress indicator to the visualization
# making this connection automatically passes the "0% done" status message to the
# dialog, which causes the dialog to be shown.
sumpf.connect(indicator.GetProgressAsTuple, dialog.SetProgress)

# start the "calculation"
tester1.SetValue(1.0)
# now the custom visualization will print the status messages from "20% done" to
# "100% done".
# And the dialog will update itself according to the current progress.

# After the calculation has finished, the progress indicator is no longer in use.
# Running the "calculation" again will not result in additional progress messages.
tester1.SetValue(1.0)</pre>
				</td>
			</tr>
			<tr>
				<td></td>
				<td width="100%"></td>
				<td></td>
			</tr>
		</table>
	</body>
</html>

